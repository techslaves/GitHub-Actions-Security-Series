# 1: GitHub Actions Security â€“ Threat Landscape & Basics

## CI/CD attack surface
The "Attack Surface" refers to all the places where a hacker can try to break into your pipeline.

| Component | Risk Level | Why it's a target |
| --- | --- | --- |
| **Secrets** | Critical | API keys, Cloud credentials, and Database passwords. |
| **Triggers** | High | Events like `pull_request` can allow outsiders to trigger your code. |
| **Dependencies** | High | Using 3rd-party actions or libraries can introduce "poisoned" code. |
| **Runner Environment** | Medium | If a runner is compromised, an attacker can move into your private network. |

## Common CI/CD Attacks

### **Credential Leakage**

The most common mistake. Developers accidentally print secrets to the console during debugging. While GitHub tries to mask secrets with `***`, there are ways to bypass this (e.g., base64 encoding the secret before printing).

### **Malicious Pull Requests (PRs)**

An attacker forks your public repo, modifies the `.github/workflows/` file to include a command that steals your secrets, and submits a PR. If your workflow runs automatically on PRs, their malicious code might execute using *your* project's secrets.

### **Dependency Confusion**

Attackers publish a malicious package to a public registry (like npm or PyPI) with the same name as a private internal package used in your CI. If your runner isn't configured correctly, it might download the malicious public version instead of your safe private one.

### **Runner Compromise**

- **Shared Runners:** Hosted by GitHub. They are ephemeral (deleted after use), making them very safe.
- **Self-Hosted Runners:** Servers you manage. If an attacker gains access, they can potentially stay on the machine (persistence) and attack other parts of your internal network.

## ðŸŽ¬ Demo: Secret Leakage via Logs

### **The Insecure Workflow**

**Method 1: The Character Split (Way to expose secret**)

Create a file at `.github/workflows/leak-demo.yml`:

YAML

```yaml
name: Security Leak Demo
on: [push]

jobs:
  leak-job:
    runs-on: ubuntu-latest
    steps:
      - name: Attempting to print secret (Masked)
        run: echo "My secret is ${{ secrets.MY_API_KEY }}"

      - name: Bypass Masking (LEAK!)
        # This converts the secret to base64, so GitHub's filter doesn't recognize it.
        run: |
          SECRET="${{ secrets.MY_API_KEY }}"
          echo "$SECRET" | sed 's/./& /g'
```

**Method 2: The Git Commit Leak (Way to expose secret**)

```yaml
jobs:
  leak-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
	  - name: Commit Secret to Repo
        run:|
          # Configure Git
          git config --global user.name "Security-Bot"
          git config --global user.email "bot@example.com"
          
          # Write secret to a file
          echo "${{ secrets.MY_API_KEY }}" > leaked_secret.txt
          
          # Push to the repository
          git add leaked_secret.txt
          git commit -m "Exfiltrating secret to repo history"
          git push
```

**Method 3: PR from a forked repository**
```yaml
name: Security Leak Demo
on: 
  pull_request_target:
    types: [opened]

permissions:
  contents: write
  id-token: write
  
jobs:
  leak-job:
    runs-on: ubuntu-latest
    steps:   
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Attempting to print secret (Masked)
        run: echo "My secret is ${{ secrets.MY_API_KEY }}"

      - name: Bypass Masking (LEAK!)
        run: |
          SECRET="${{ secrets.MY_API_KEY }}"
          echo "$SECRET" | sed 's/./& /g'
```