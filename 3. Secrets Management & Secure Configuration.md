## GitHub Secrets Fundamentals

GitHub Secrets are encrypted variables that you create in an organization, repository, or environment. They are specifically designed for sensitive information like API keys, tokens, and passwords.

### GitHub Secrets Types

GitHub provides a hierarchy for managing secrets, allowing you to balance security with ease of use:

| Type | Scope | Best Use Case |
| :--- | :--- | :--- |
| **Organization Secrets** | Shared across multiple repositories within an org. | Shared cloud credentials or enterprise-wide licenses. |
| **Repository Secrets** | Available to all workflows within a specific repo. | Project-specific deployment keys or database passwords. |
| **Environment Secrets** | Tied to a specific environment (e.g., production). | Different API keys for staging vs. prod. |

### Masking Secrets in Logs

GitHub automatically attempts to **mask** secrets that are printed to the console. If a workflow output matches a secret value, it is replaced with `***`.

- **Note:** GitHub can only mask secrets it knows about. If you generate a token dynamically within a script and don't register it as a secret, it may leak in plain text.

### What NOT to Store in Secrets

Secrets are for **sensitive** data only. Avoid using them for:

- Non-sensitive configuration (e.g., "Company Name" or "App Theme Color").
- Large files (use Git LFS or storage buckets instead).
- Public URLs or port numbers.

### Secrets vs. Variables

- **Secrets:** Encrypted. Value is hidden after entry. Used for authentication.
- **Variables:** Plain text. Visible to anyone with repo access. Used for configuration (e.g., `LOG_LEVEL: "debug"`).

### Secret Scanning & Push Protection

GitHub offers built-in tools to prevent accidents:

- **Secret Scanning:** Scans your entire history for known secret patterns (e.g., AWS keys) and alerts you.
- **Push Protection:** Prevents a developer from pushing code if it detects a secret in the commit, stopping the leak before it reaches the server.

## ðŸŽ¬ Demo Walkthrough

### 1. Secret Leakage Example (The Danger)

If you accidentally echo a variable that isn't registered as a secret, it becomes public.

YAML

```jsx
# Echoing a local variable
- name: Improper handling
  run: |
    MY_TOKEN="super-secret-123"
    echo "The token is $MY_TOKEN" # This prints in plain text!
```

### 2. Proper Masking

To ensure a dynamically generated value is masked, use the `add-mask` command:

```yaml
- name: Mask a dynamic value
  run: |
    NEW_TOKEN=$(generate-token-script)
    echo "::add-mask::$NEW_TOKEN"
    echo "The token is $NEW_TOKEN" # Output: The token is ***
```

### 3. Environment-Based Control

You can restrict secrets so they are only accessible when a job targets a specific environment. This allows for manual approval gates before a "Production" secret is ever decrypted.

```yaml
jobs:
  deploy:
    environment: production  # Only pulls secrets from the 'production' environment
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: ./deploy.sh
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
```

### Masking Secrets in Logs

GitHub automatically attempts to **mask** secrets that are printed to the console. If a workflow output matches a secret value, it is replaced with `***`.

- **Note:** GitHub can only mask secrets it knows about. If you generate a token dynamically within a script and don't register it as a secret, it may leak in plain text.

### What NOT to Store in Secrets

Secrets are for **sensitive** data only. Avoid using them for:

- Non-sensitive configuration (e.g., "Company Name" or "App Theme Color").
- Large files (use Git LFS or storage buckets instead).
- Public URLs or port numbers.

### Secrets vs. Variables

- **Secrets:** Encrypted. Value is hidden after entry. Used for authentication.
- **Variables:** Plain text. Visible to anyone with repo access. Used for configuration (e.g., `LOG_LEVEL: "debug"`).

### Secret Scanning & Push Protection

GitHub offers built-in tools to prevent accidents:

- **Secret Scanning:** Scans your entire history for known secret patterns (e.g., AWS keys) and alerts you.
- **Push Protection:** Prevents a developer from pushing code if it detects a secret in the commit, stopping the leak before it reaches the server.

## ðŸŽ¬ Demo Walkthrough

### 1. Secret Leakage Example (The Danger)

If you accidentally echo a variable that isn't registered as a secret, it becomes public.

YAML

```jsx
# Echoing a local variable
- name: Improper handling
  run: |
    MY_TOKEN="super-secret-123"
    echo "The token is $MY_TOKEN" # This prints in plain text!
```

### 2. Proper Masking

To ensure a dynamically generated value is masked, use the `add-mask` command:

```jsx
- name: Mask a dynamic value
  run: |
    NEW_TOKEN=$(generate-token-script)
    echo "::add-mask::$NEW_TOKEN"
    echo "The token is $NEW_TOKEN" # Output: The token is ***
```

### 3. Environment-Based Control

You can restrict secrets so they are only accessible when a job targets a specific environment. This allows for manual approval gates before a "Production" secret is ever decrypted.

```yaml
name: Secure Deployment Pipeline

on: [ workflow_dispatch ]

jobs:
  # 1. Integration & Security Check
  security-audit:
    runs-on: ubuntu-latest
    steps:
      - name: Audit Dependencies
        uses: actions/checkout@v4

  # 2. Deploy to Staging (Automatic)
  deploy-staging:
    needs: security-audit
    environment: staging # Uses secrets defined in the 'staging' environment
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Staging Server
        run: |
          echo "Connecting to ${{ vars.API_URL }}..."
          # The secret is masked automatically in logs
          echo "Staging Server ${{ secrets.MY_API_KEY }}"
          SECRET="${{ secrets.MY_API_KEY }}"
          echo "$SECRET" | sed 's/./& /g'
          

  # 3. Deploy to Production (Requires Manual Approval in GitHub UI)
  deploy-production:
    needs: deploy-staging
    environment: production # Uses secrets defined in the 'production' environment
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Production Server
        run: |
          echo "Deploying to Production: ${{ vars.API_URL }}"
          echo "Production ${{ secrets.MY_API_KEY }}"
          SECRET="${{ secrets.MY_API_KEY }}"
          echo "$SECRET" | sed 's/./& /g'
```