## The Runner Security Model

### GitHub-Hosted Runner Isolation

GitHub-hosted runners use a "Zero Trust" isolation model. Every job runs in a fresh, clean Virtual Machine (VM) that is destroyed immediately after the job finishes.

**- Virtualization:** Jobs run in a dedicated VM (Azure), providing strong hardware-level isolation.

**- Network:** Runners have restricted access to internal GitHub services.

**- No Persistence:** No data, background processes, or file changes survive between jobs.

### Risks of Self-Hosted Runners

Self-hosted runners are often chosen for cost or access to private networks, but they introduce several "backdoors":

**- Persistent Compromise:** If a malicious job leaves a backdoor (like a cron job or a reverse shell), it can infect every subsequent job that runs on that same machine.

**- Network Pivot:** Because the runner is inside your private network (VPC/VPN), an attacker who compromises a workflow can "lateral move" to your databases, internal APIs, or production servers.

**- Resource Exhaustion:** A "fork bomb" or crypto-miner in a malicious PR can take down your build server, halting all development.

### Ephemeral vs. Persistent Runners

| Feature | Persistent (Traditional) | Ephemeral (Modern/Safe) |
| :--- | :--- | :--- |
| **State** | Keeps files/cache between jobs. | Wiped clean after every job. |
| **Security** | High risk of "poisoning" the runner. | Low risk; similar to GitHub-hosted. |
| **Configuration** | Use `./run.sh` as a background service. | Use `--ephemeral` flag with a controller. |


### Running Actions Inside Containers

You can add a layer of defense-in-depth by forcing jobs to run inside a Docker container even on a self-hosted host.

```yaml
jobs:
  secure-job:
    runs-on: self-hosted
    container:
      image: node:18-slim # This job runs isolated inside this container
```

üé¨ Demo: Self-Hosted Runner Misconfiguration
The "Persistent Backdoor" Example

- **The Attack:** An attacker submits a Pull Request with a "test" step that silently creates a hidden file in the runner's home directory: run: echo "I am watching" > ~/.bashrc

- **The Persistence:** Because the runner is persistent, the next developer who runs a job on this machine will execute the attacker's code the moment a shell starts.

- **The Fix:** Use the --ephemeral flag when starting the runner: ./config.sh --url <url> --token <token> --ephemeral This tells GitHub to unregister and shut down the runner after exactly one job.

### üõ°Ô∏è Hardening Checklist

If you must use self-hosted runners, follow this checklist:

- **[ ] Use Ephemeral Mode:** Always reset the environment after every job.

- **[ ] Dedicated User:** Run the runner process as a non-root user (e.g., a github-runner user).

- **[ ] Network Egress Filtering:** Use a firewall to block the runner from talking to any internal IP addresses it doesn't strictly need.

- **[ ] No Public Repos:** Never use self-hosted runners for public repositories where anyone can submit a Pull Request.

- **[ ] Just-in-Time (JIT) Tokens:** Use JIT runner registration to avoid long-lived PATs on your servers.